% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PackageOxygen.R
\name{predict.hill.ts}
\alias{predict.hill.ts}
\title{Predict the adaptive Survival or Quantile function for a time serie}
\usage{
\method{predict}{hill.ts}(object, X, t, pgrid = 1:(length(X) - 1)/length(X),
  xgrid = X, type = "quantile", ...)
}
\arguments{
\item{object}{output object of the function hill.ts.}

\item{X}{a vector of the observed values, same as the function hill.ts.}

\item{t}{a vector of time covariates which should have the same length as X, same as the function hill.ts.}

\item{pgrid}{used if type = "quantile", a vector of probabilities.}

\item{xgrid}{used if type = "survival", a vector of values.}

\item{type}{either "quantile" or "survival".}

\item{...}{further arguments passed to or from other methods.}
}
\value{
\item{pgrid}{the input vector of probabilities.}
  \item{xgrid}{the input vector of values.}
  \item{Tgrid}{Tgrid output of the function hill.ts.}
  \item{quantiles}{the quantiles assiociated to pgrid.}
  \item{surv}{the survival function assiociated to xgrid.}
}
\description{
Give the adaptive survival function or quantile function of a time serie
}
\details{
If type = "quantile", \eqn{pgrid} must be between 0 and 1. If type = "survival", \eqn{xgrid} must be in the domain of the data from the function \code{hill.ts}.
}
\examples{
#Generate a pareto mixture sample of size n with a time varying parameter
theta <- function(t){
   0.5+0.25*sin(2*pi*t)
 }
n <- 4000
t <- 1:n/n
Theta <- theta(t)
Data <- NULL
set.seed(1240)
for(i in 1:n){
   Data[i] <- rparetomix(1, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75, precision = 10^(-5))
 }
\dontrun{ #For computing time purpose
  #choose the bandwidth by cross validation
  Tgrid <- seq(0, 1, 0.1)#few points to improve the computing time
  hgrid <- bandwidth.grid(0.01, 0.2, 20, type = "geometric")
  hcv <- bandwidth.CV(Data, t, Tgrid, hgrid, TruncGauss.kernel,
         kpar = c(sigma = 1), pcv = 0.99, CritVal = 3.6, plot = TRUE)
  h.cv <- hcv$h.cv

  #we modify the Tgrid to cover the data set
  Tgrid <- seq(0, 1, 0.02)
  hillTs <- hill.ts(Data, t, Tgrid, h = h.cv, TruncGauss.kernel, kpar = c(sigma = 1),
           CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  p <- c(0.999)
  pred.quantile.ts <- predict(hillTs, Data, t, pgrid = p, type = "quantile")
  true.quantile <- NULL
  for(i in 1:n){
     true.quantile[i] <- qparetomix(p, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
   }
  plot(Tgrid, log(as.numeric(pred.quantile.ts$quantiles)),
       ylim = c(0, max(log(as.numeric(pred.quantile.ts$quantiles)))), ylab = "log(0.999-quantiles)")
  lines(t, log(true.quantile), col = "red")
  lines(t, log(Data), col = "blue")


  #comparison with other fixed bandwidths

  plot(Tgrid, log(as.numeric(pred.quantile.ts$quantiles)),
       ylim = c(0, max(log(as.numeric(pred.quantile.ts$quantiles)))), ylab = "log(0.999-quantiles)")
  lines(t, log(true.quantile), col = "red")

  hillTs <- hill.ts(Data, t, Tgrid, h = 0.1, TruncGauss.kernel, kpar = c(sigma = 1),
                    CritVal = 3.6, gridlen = 100,initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts <- predict(hillTs, Data, t, p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$quantiles)), col = "green")


  hillTs <- hill.ts(Data, t, Tgrid, h = 0.3, TruncGauss.kernel, kpar = c(sigma = 1),
               CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts <- predict(hillTs, Data, t, p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$quantiles)), col = "blue")


  hillTs <- hill.ts(Data, t, Tgrid, h = 0.04, TruncGauss.kernel, kpar = c(sigma = 1),
             CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts <- predict(hillTs, Data,t ,p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$quantiles)), col = "magenta")
}



}
\seealso{
\code{\link{hill.ts}}
}

